package nthUglyNumber;

import java.util.*;

/**
 * LCR 168. 丑数
 *
 * 给你一个整数 n ，请你找出并返回第 n 个 丑数 。
 * 丑数 就是质因子只包含 2、3 和/或 5 的正整数。
 */

/**
 * 根据丑数的定义，分析得如下结论：
 * 1 是最小的丑数。
 * 对于任意一个丑数 x，其与任意的质因数（2、3、5）相乘，结果（2x、3x、5x）仍为丑数。
 */
public class Solution {


    /**
     * 优先队列（小根堆）+ Set
     *
     * 1. 起始先将最小丑数 1 放入队列
     * 2. 每次从队列取出最小值 x，然后将 x 所对应的丑数 2x、3x 和 5x 进行入队。
     * 3. 对步骤 2 循环多次，第 n 次出队的值即是答案。
     * 为了防止同一丑数多次进队，我们需要使用数据结构 Set 来记录入过队列的丑数。
     *
     * 思路简单，但是使用最小堆，会预先存储较多的丑数（取出1个存入了3个，可能求第n个丑数并不会用到那么多），维护最小堆的过程也导致时间复杂度较高。
     *
     * @param n
     * @return
     */
    // 时间复杂度：O(nlogn)。分析：得到第 n 个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，
    // 因此每次循环的时间复杂度是 O(log(3n) + 3log(3n)) = O(logn)，总时间复杂度是 O(nlogn)。
    // 空间复杂度：O(n)。分析：最小堆和哈希集合的大小都不会超过 3n。
    // public int nthUglyNumber(int n) {
    //     int[] nums = new int[]{2, 3, 5};    // 乘数
    //     // 这里都要用long类型，因为x乘上2，3，5用int可能会越界
    //     Set<Long> set = new HashSet<>();
    //     PriorityQueue<Long> pq = new PriorityQueue<>(n);    // 小根堆
    //     set.add(1L);
    //     pq.add(1L);
    //     for (int i = 1; i <= n; i++) {
    //         long x = pq.poll();
    //         if (i == n) {
    //             return (int) x;
    //         }
    //         for (int num : nums) {
    //             long t = num * x;
    //             if (!set.contains(t)) { // 之前已经如果队得说明是重复元素，不要再次入队
    //                 set.add(t);
    //                 pq.add(t);
    //             }
    //         }
    //     }
    //     return -1;
    // }


    /**
     * 多路归并，三指针
     *
     * 丑数序列：1，2，3，4，5，6，8，9，10，12...中除1以外后面的所有丑数都是通过已有丑数乘上质因数2、3、5得来
     * 因此1后面的所有丑数都是按照升序从以下三个序列中选出来的：
     * 由 丑数 x 2 得到得有序数列：1x2, 2x2, 3x2, 4x2, 5x2, 6x2, 8x2...
     * 由 丑数 x 3 得到得有序数列：1x3, 2x3, 3x3, 4x3, 5x3, 6x3, 8x3...
     * 由 丑数 x 5 得到得有序数列：1x5, 2x5, 3x5, 4x5, 5x5, 6x5, 8x5...
     * 也就是说，这三个序列就覆盖了1后面的所有丑数，当然其中会有重复得丑数，因此遇到重复的不要算多次，保证丑数序列严格递增
     *
     * 所以接下来要做的就是从这三个序列中按照升序挑选丑数且跳过重复的丑数
     *
     * @param n
     * @return
     */
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)
    public int nthUglyNumber(int n) {
        // 下标0不用，从1开始，uglyArr[i]代表第i个丑数
        int[] uglyArr = new int[n + 1];
        uglyArr[1] = 1; // 最小的丑数为1
        int i2 = 1, i3 = 1, i5 = 1; // 指向对应的有序序列中待挑选的位置，如 i2 = k 表示在丑数x2得到的序列中 uglyArr[k] * 2 待挑选

        for (int i = 2; i <= n; i++) {  // i表示当前正要确定第i个丑数
            int u2 = uglyArr[i2] * 2, u3 = uglyArr[i3] * 3, u5 = uglyArr[i5] * 5;   // 注意具体待挑选的三个丑数需要根据uglyArr已确认的丑数乘上对应质因数得到
            // 将3个有序序列中的候选数的最小值存入已有丑数序列（即三个里面选最小的作为本次确定的丑数），并将其下标右移
            int min = Math.min(u2, Math.min(u3, u5));
            uglyArr[i] = min;
            // 由于可能不同的序列之间产生了相同的丑数，需要保证不重复添加同一个数，因此相等的丑数需要跳过（只要等于min的候选数对应指针都要右移，因此这里不能使用 else if）
            if (min == u2) {
                i2++;
            }
            if (min == u3) {
                i3++;
            }
            if (min == u5) {
                i5++;
            }
        }
        return uglyArr[n];
    }
}
